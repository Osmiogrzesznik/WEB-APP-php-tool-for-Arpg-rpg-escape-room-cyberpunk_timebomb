<script>
tableData = <?= json_encode($resultset,JSON_PRETTY_PRINT); ?>;

baseurl = "<?=$_SERVER['SCRIPT_NAME'] ?>";
UpdateUrl = "<?=$_SERVER['SCRIPT_NAME'] ?>?action=updatedevice";


feedbackPRE = document.querySelector("#feedback");
function logfdb(msg){
  feedbackPRE.innerText += "\n" + msg
}



var map;
var mapDefaultZoom = 10;
var vectorLayer;
var atomIcons = {};

        function NuMap(mapLat,mapLng,mapDefaultZoom) {
            return new ol.Map({
                target: "map",
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.OSM({
                            url:"https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png",
                            urluuu: "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png"
                        })
                    })
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([parseFloat(mapLng), parseFloat(mapLat)]),
                    zoom: mapDefaultZoom
                })
            });
        }


    

        function NuLayer(arrayOfFeatures,style=null) {
            return new ol.layer.Vector({
                source: new ol.source.Vector({
                    features: arrayOfFeatures
                }),
                style: null
            });
        }



        function NuFeature(id,status, lat, lng) {
            let f = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.transform([parseFloat(lng),
                    parseFloat(lat)
                ], 'EPSG:4326', 'EPSG:3857')),
                id: id,
            });
            
            f.setStyle(NuStyle(id,status));
            return f;
        }

        function NuStyle(text,imagename){
            return new ol.style.Style({
                    image: atomIcons[imagename],
                    text: new ol.style.Text({
                        text:text,
                        offsetY: 20,
                        font: "bold 20px sans-serif",
                        stroke: new ol.style.Stroke({
                            width: 3,
                            color: "#ffffff"
                        })
                    })
                })
        }

        function NuIcon(imagename){
            return new ol.style.Icon({
                        anchor: [0.5, 0.5],
                        anchorXUnits: "fraction",
                        anchorYUnits: "fraction",
                        src: "img/" + imagename + ".png"
                    })
        }


        function showDevices(devices) {
          if (devices.length<1){
            return;
          }
          isThereAnyDeviceWithLocation = false;
          for(let i = 0; i<devices.length; i++){
            let dv = devices[i];
            //alert(dv.device_location);
            doesDvHaveLocation = ![null,"no location",undefined].includes(dv.device_location);
           isThereAnyDeviceWithLocation = isThereAnyDeviceWithLocation || doesDvHaveLocation;
            
          }
          if(!isThereAnyDeviceWithLocation){
            return; //dont make map
          }

          devicesWithLocation = [];
          for(let i = 0; i<devices.length; i++){
            let dv = devices[i];
            doesDvHaveLocation = ![null,"no location",undefined].includes(dv.device_location);
            
            if(doesDvHaveLocation){
              locOb = {};
                locArr = dv.device_location.split("/");
              locOb.latitude = locArr[0];
              locOb.longitude = locArr[1];
              dv.location = locOb; 
            devicesWithLocation.push(dv);
            }
          }




            atomIcons = {
                disarmed: NuIcon("disarmed"),
                created: NuIcon("created"),
                active: NuIcon("active")
            }

            window.map = NuMap(devicesWithLocation[0].location.latitude, devicesWithLocation[0].location.longitude,mapDefaultZoom);
            arrayOfFeaturesAll = devicesWithLocation.map(dv=>{
              return NuFeature(dv.device_name,dv.device_status,dv.location.latitude,dv.location.longitude)
            })

            allLayer = NuLayer(arrayOfFeaturesAll);
            map.addLayer(allLayer);
        }


        if (tableData.length>0 ){
          isThereAnyDeviceWithLocation = false;
          for(let i = 0; i<tableData.length; i++){
            let dv = tableData[i];
            //alert(dv.device_location);
            doesDvHaveLocation = ![null,"no location",undefined].includes(dv.device_location);
           isThereAnyDeviceWithLocation = isThereAnyDeviceWithLocation || doesDvHaveLocation;
          }

          if(isThereAnyDeviceWithLocation){

            document.querySelector("#mapDIV").innerHTML = '<div id="map" style="width: 70vw; height: 70vh;"></div>';
  window.addEventListener("load",function(){showDevices(tableData)});
          }

}



alert(2);
</script>
<script>

function DataField(name,value){
  this.name = name;
  this.value = value;
}

timeoutID = null;
isAutoReloadOn = false;

function ToggleAutoReloading(turniton = false){
  
if(isAutoReloadOn && turniton){
  return;
}
  setTimeout(x=>document.location.reload(true),10000);

}

function sendUpdate(id, tr_row){
  var FD  = new FormData();
  let deviceRow = tableToEdit.querySelector("#r" + id);
  let editables = deviceRow.querySelectorAll(".field-editable");
  let fields = [];
  fields.push(new DataField("updatedevice",true));
  fields.push(new DataField("device_id",id));
  FD.append("updatedevice",true);
  FD.append("device_id",id);
   for (let idx = 0; idx < editables.length; idx++){
      val = editables[idx].innerText;
      if (!val) {
        val = editables[idx].value;
        val = !val ? "":val; //replace nullish values with empty string
      }
      name = editables[idx].dataset.columnName;
      datafield = new DataField(name,val);
      fields.push(datafield)
      FD.append(name,val);
   }


  //  alert(JSON.stringify(fields));
  //  return;


   fetch(UpdateUrl, {
        method: 'POST', // *GET, POST, PUT, DELETE, etc.
        // mode: 'cors', // no-cors, cors, *same-origin
        // cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
        credentials: 'include', // include, *same-origin, omit
        // headers: {
        //    // 'Content-Type': 'application/json',
        //      'Content-Type': 'application/x-www-form-urlencoded',
        // },
        // redirect: 'follow', // manual, *follow, error
        // referrer: 'no-referrer', // no-referrer, *client
        body: FD // body data type must match "Content-Type" header
    })
    .then(response => response.text())
    .then(t => {
      feedbackPRE = document.querySelector("#feedback");
      if (feedbackPRE){
        feedbackPRE.innerText = t;
       // setTimeout(x=>open(baseurl),1000)
      }
      else{
        alert(t)
      }
    });
    ; // parses JSON response into native JavaScript objects 

  console.log(fields)


	alert(id);
}


let table = document.getElementById('tableToEdit');

let editingTd;


if (table){
table.onclick = function(event) {

  // 3 possible targets
  let target = event.target.closest('.edit-cancel,.edit-ok,td');

  if (!table.contains(target)) return;

  if (target.className == 'edit-cancel') {
    finishTdEdit(editingTd.elem, false);
  } else if (target.className == 'edit-ok') {
    finishTdEdit(editingTd.elem, true);
  } else if (
	  target.nodeName === 'TD' && target.className==="field-editable" && !editingTd ) { //  not already editing
      makeTdEditable(target);
  }

};
}

function makeTdEditable(td) {
  editingTd = {
    elem: td,
    data: td.innerHTML
  };

  td.classList.add('edit-td'); // td is in edit state, CSS also styles the area inside

  let textArea = document.createElement('textarea');
  textArea.style.width = td.clientWidth + 'px';
  textArea.style.height = td.clientHeight + 'px';
  textArea.className = 'edit-area';

  textArea.value = td.innerText;
  td.innerHTML = '';
  td.appendChild(textArea);
  textArea.focus();

  td.insertAdjacentHTML("beforeEnd",
    '<div class="edit-controls"><button class="edit-ok">OK</button><button class="edit-cancel">CANCEL</button></div>'
  );
}

function finishTdEdit(td, isOk) {
  if (isOk) {
    td.innerHTML = td.firstChild.value;
  } else {
    td.innerHTML = editingTd.data;
  }
  td.classList.remove('edit-td');
  editingTd = null;
}




function Watchmode(){
  this.interval = 5000;
  this.urlgetalldevices  =  baseurl + "?action=js_getalldevices";
  this.isOn = false;
  this.IID  =  null;
this.btnOrigbg = "";
this.firstTime = true;
  this.toggle = function(btn){
   this.isOn = !this.isOn;
    btn.style.border = this.isOn ? "4px solid yellow":"";
    btn.style.backgroundColor = this.isOn ? "yellow":"";
btn.style.color= this.isOn ? "black":"";
    popsound ? popsound.play():0; //play the sound if exists
    return this.isOn ? this.start():this.stop();
  };
  this.start = function(){
  	alert("starting watchmode");
    this.IID = setInterval(x=>this.fetchToUpdate(),this.interval);
    this.fetchToUpdate();
  };
  this.stop = function(){
    clearInterval(this.IID);
  };
  this.fetchToUpdate = function(){
    fetch(this.urlgetalldevices,{credentials:"include"})
    .then(x=>x.json())
    .then(data=>this.update(data))
  };
  this.update= function(data){
    console.log(data);
    feedback.innerText += "fetchOK";
    cols = data.columnNames;
    rows = data.rows;

    for(let i = 0; i<rows.length; i++){
      let row = rows[i];
      tr = tableToEdit.querySelector("#r"+row.device_id);
      if (!tr){ // new Device was added that is not yet in table
     // trTMPL = tableToEdit.querySelector("#r")*****
        open(baseurl);//just open new window - to much hassle ?
        return;
      }
      // later in api you can make it so cols are not all send
      // so only important/changeable stuff is updated
      for(let ci= 0; ci<cols.length; ci++){
      col = cols[ci]
        field = tr.querySelector("#r"+row.device_id+col);
        let old = field.innerText 
let anew= row[col];
if (old != anew){
	field.innerText = anew;
	field.classList.add("updatedAnim");
  field.classList.add("changed");
  popsound ? popsound.play():0; //play the sound if exists
  window.fieldonlater = field;
	setTimeout(x=>{
    //alert(fieldonlater.classList)
    fieldonlater.classList.remove("updatedAnim")}
    ,1000);
	
	}// end of if
      }//end of for
    
  }//end of for
}//end of update

}//end of watchmode func
watchmode = new Watchmode();


</script>